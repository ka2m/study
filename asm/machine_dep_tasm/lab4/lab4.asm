.model small
.stack 100h                     ; объявление сегмента стека
.386                            ; использовать расширения 386 процессора
.data ; переменные
numbers dw 2 dup (10 dup (?))   ; двумерный массив чисел
outstr db '    $'               ; строка-маска для вывода числа
.code ;Начало сегмента кода

fill proc ; процедура заполнения массива
    next:
        push ax                 ; сохраняем оригинальный АХ
        mul ax                  ; возводим в квадрат

        mov numbers[bx][di], ax ; записываем квадрат в "вторую строчку"

        pop ax                  ; возвращаем оригнальное число
        mov numbers[di], ax     ; запсываем оригинальное число в "первую строчку"

        add ax, 5               ; увеличиваем число на 5, получаем
                                ; следующее число "первой строки"

        add di, 2               ; переход к следующему элементу массива
                                ; (массив слов - нужно +2)
        loop next
    ret                         ; возврат в основную програаму
endp fill

print_tab proc ; вывод \t
    push ax     ; сохраняем на всякий случай используемые регистры
    push dx

    mov dl, 09h ; символ табуляции
    mov ah, 02h ; вывод символа на экран

    int 21h     ; вывод на экран

    pop dx      ; восстанавливаем регистры
    pop ax
    ret
endp print_tab

print_newline proc ; перевод строки
    push ax
    push dx

    mov dl, 0Ah ; символ новой строки
    mov ah, 02h

    int 21h

    mov dl, 0Dh ; символ возврата каретки
    mov ah, 02h

    int 21h

    pop dx
    pop ax
    ret
endp print_newline

restore_str proc ; восстановление строки-маски
    push dx                 ; сохранение используемых регистров
    push di

    mov dl, ' '             ; пробельный символ
    mov di, 3               ; будем использовать в качестве
                            ; счетчика для цикла
    sym:
        mov outstr[di], dl  ; запись с конца
        dec di              ; переход к предыдущему байту
        cmp di, 0           ; если не ноль, то
                            ; восстановим предыдущий символ
        jne sym
    pop di                  ; восстановим регистры
    pop dx
    ret
endp restore_str

print_number proc ; формирование строки-маски и вывод ее на экран
    push bx                 ; bx используется в делении,
                            ; а также для перехода по строкам массива

    push di                 ; используется для доступа
                            ; к элементам в "строке"

    mov di, 3               ; счетчик позиции в строке-маске
    itm:                    ; метка для цикла
        xor dx, dx          ; сброс DX

        mov bx, 10          ; делитель в десятичной СС
        div bx              ; делим, получаем переведенную
                            ; младшую цифру в остатке

        add dl, 30h         ; добавляем в остаток 30 для записи цифры
                            ; строка маска используется наподобие
                            ; стека в 3.1 - заполняется с конца

        mov outstr[di], dl  ; добавляем в конец строки символ цифры
        dec di              ; переход к следующему символу строки
        cmp ax, 0           ; если AX еще не 0
        jne itm             ; делаем все заново

    mov ah, 09h             ; вывод строки
    mov dx, offset outstr   ; адрес начала строки
    int 21h                 ; вызов прерывания

    call restore_str        ; восстановление строки

    pop di                  ; восстановление регистров
    pop bx
    ret                     ; возвращаемся в процедуру обхода массива
endp print_number

print proc ; обход массива с целью вывода на экран
    mov cx, 2                        ; число строк
    rows:
        push cx                      ; запоминаем число строк

        mov cx, 10                   ; число элементов в строке

        arow:                        ; внутренний цикл
            mov ax, numbers[bx][di]  ; доступ к следующему числу массива
                                     ; по формуле DS+BX+DI

            call print_number        ; вывод числа на экран

            add di, 2                ; переход к следующему элементу массива, тк
                                     ; он состоит из слов, а не байтов, как строка

            call print_tab           ; вывод \t
            loop arow                ; пока строка не кончится

        call print_newline           ; вывод \n\r

        pop cx                       ; восстановление счетчика внешнего цикла

        xor di, di                   ; сброс счетчика по строке на 0

        mov bx, 20                   ; переход к следующей строке
                                     ; можно было и add bx,20, но всего 2 строки
        loop rows
    ret
endp print

start: ;Выполнение программы
    mov ax, @data ; получение реального адреса сегмента данных
    mov ds, ax    ; его сохранение в сегмент данных

    xor di, di    ; di - итератор по элементам строки в основной процедуре
    mov ax, 5     ; нулевой элемент нулевой строки
    mov cx, 10    ; длина строки
    mov bx, 20    ; смещение следующей строки (10 элементов-слов, те по 2 байта)

    call fill     ; заполнение массива

    xor di, di    ; сброс итератора по строкам
    xor bx, bx    ; и столбцам

    call print    ; вывод массива на экран

    mov ax, 4C00h ; выход
    int 21h
end start
