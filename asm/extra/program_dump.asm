.model small ;exe-программа с 64кб сегментами
.stack 100h ; стек 64 кб
.486 ; использовать расширения 486 процессора
.code ; сегмент кода
start: ; начало программы

; макрос подготовки экрана и его очистки
; int 10,6 - прокрутка экрана вверх
; прокрутка вверх от cx до dx
; cx - 00 00 - левый верхний уго
; dx - 24 79 - правый нижний
prepscr macro
    pusha
    mov ah, 06h
    mov bh, 07h
    xor cx, cx
    mov dx,184Fh
    int 10h
    popa
endm

; марос вывода пробельного символа
; вывод через запись в видеопамять по адресу ES:SI
; Аттрибут - 07 (белым по черному)
; Символ  - 20h
; Смещение на одно слово, так как в es:[si] записывается слово
wspace macro
    push bx
    mov bx, 0720h
    mov es:[si], bx
    add si, 2
    pop bx
endm

; макрос вывода одного символа байта машинного кода
; байт лежит в BL
; если его значение больше6 чем A
; добавим 7
; затем в любом случае добавим 30 для получения ASCII кода
; запишем в видеопамять по адресу es:[si] с аттрибутом 07
wsymbol macro
    local hexno, ready
    cmp bl, 0Ah
    jge hexno
    jmp ready
    hexno:
        add bl, 7h
    ready:
        add bl, 30h
    push bx
    mov bh, 07h
    mov es:[si], bx
    add si, 2
endm

mov ax, 0B800h ; подготовка видеорежима
mov es, ax  ; загрузка адреса

xor si, si ; сброс "итераторов"
xor di, di

mov cx, offset exit ; вычислим адрес метки конца программы
sub cx, offset start ; вычислим адрес входа в программу, обычно 0
add cx, 5 ; добавим размер команд после метки exit

prepscr ; подготовка экрана

; основной цикл программы
wdump:
    mov bl, cs:di ; в bl получаем один байт машинного кода из сегмента CS
    add di, 1 ; перейдем к следующему байту
    push bx ; запомним BL
    and bl, 0F0h ; получим старшую цифру
    shr bl, 4 ; сделаем ее младшей
    wsymbol ; запишем в видеопамять
    pop bx ; восстановим BL и получим младшую цифру
    and bl, 0Fh
    wsymbol
    wspace ; запись пробела в видеопамять
    loop wdump

exit: ; метка для правильного подсчета размера программы
    ; выход
    mov ax,4C00h
    int 21h
end start
