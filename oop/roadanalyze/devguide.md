Road Analyze
=====
# Руководство разработчика

## Cодержание

* [Описание проекта](#general)
* [Стек разработки](#stack)
* [Основные компоненты проекта](#comp)
* [Алгоритмы и структуры данных](#ads)
* [Модели](#model)
* [Контроллеры](#control)
	* [Контроллер: addcar](#addcar)
	* [Контроллер: addroad](#addroad)
	* [Контроллер: addplace](#addplace)
	* [Контроллер: viewstat](#viewstat)
	* [Контроллер: index](#index)
* [Представления](#view)
* [Маршрутизаторы](#url)
* [Примеры и функции](#funcs)
	* [Работа с автомобилем](#workcar)
		* [add_car](#add_car_fn)
		* [djikstra](#djikstra)
		* [generate\_connection_list](#gcl)
		* [Пример использования](#example)
	* [Пример работы с моделями](#example2)
* [Настройки](#settings)
* [Развертывание проекта] (#deploy)
* [Репозиторий](#repo)
* [Разработчик](#dev)
* [Лицензия](#license)

<a name="general"></a>
##  Описание проекта

Road Analyze (анализатор дорог) – веб-приложение, позволяюющее оценить загрузку дорог на основании данных, получаемых посредством сайта. Приложение графически визуализирует загрузку дорог при помощи столбачтой диаграммы.

---

<a name="stack"></a>
## Стек разработки

* Python 2.7
* Django 1.7.5
* matplotlib 1.4.3
* PostgreSQL 9

---

<a name="comp"></a>
## Основные компоненты проекта

Road Analyze разработан при помощи фреймворка Django на основе паттерна Модель-Представление-Контроллер, используя стандартные средства Django для реализации этого решения. 

Для отображения диаграммы используется библиотека matplotlib, которая по входным данным создает файл с расширением PNG и сохраняет на диск. 

В качестве базы данных используется PostgreSQL 9 ввиду требований заказчика. База данных находится в Docker-контейнере, что позволяет ее быстро инициализировать во время разработки (подробнее см. [Развертывание проекта](#deploy)).

Проект представляет собой совокупность нескольких взаимосвязанных веб-страниц, при помощи которых можно добавить информацию о пунктах связи дорог, дорогах или же нагрузке в базу данных или запросить данные о нагруженности дороги в какой-либо временной промежуток в пределах одного дня. 

- - -

<a name="ads"></a>
## Алгоритмы и структуры данных

В основе проекта лежит графовая модель, где вершинами графа являются точки связи дорог, так называемые _Point of Interest_, а ребрами являются сами дороги, котроые называются _Road_. Граф является взвешенным, неориентированным. Весом ребер является протяженность дороги.

Граф не является мультиграфом, то есть две вершины может напрямую соединять только лишь одна дорога. 

Более подробное описание структур данных (или же моделей) дано в соответствующем разделе.

Для вычисления маршрута используется алгоритм Дейкстры, для работы которого создается список cвязей, реализованный в виде списка, состоящего из кортежей вида `(исходный пункт, конечный пункт, протяженность)`. Такой список создается при каждом запросе нагруженности той или иной дороги.

Для хранения информации о нагруженности используется структура данных, хранящая идентификационный номер дороги, время в _секундах_, когда нагрузка появилась, и когда закончилась.

- - - 

<a name="model"></a>
## Модели

Информация о моделях хранится в файле `models.py`. Все модели – классы, которые наследуются от стандартного класса `django.db.models.Model`. Имена полей даны как в вышеобозначенном файле:

| Название модели | Описание | Поля <table><tr><td> название </td> <td> тип, ограничения </td>  <td> описание  </td></tr></table> |
|-----------------|----------|------|
| PointOfInterest | Точки связи дорог, вершины "графа" | <table><tr><td> `name` </td> <td> Символьное поле, длина 20</td>  <td> название </td></tr></table> |
| Road | Дороги, по которым проводится анализ. Дороги являются ребрами и связывают две вершины | <table><tr><td> `name` </td> <td> Символьное поле, длина 20</td>  <td> название </td></tr><tr><td> `length` </td> <td> Число с плавающей точкой</td>  <td> длина дороги </td></tr><tr><td> `point_from` </td> <td> Внешний ключ </td>  <td> PointOfInterest, из которого исходит дорога </td></tr><tr><td> `point_to` </td> <td> Внешний ключ </td>  <td> PointOfInterest, в который входит дорога </td></tr></table> |
| Car | Машина, то есть генератор нагруженности | <table><tr><td> `name` </td> <td> Символьное поле, длина 20 </td>  <td> название </td></tr><tr><td> `speed` </td> <td> Число с плавающей точкой </td>  <td> скорость автомобиля </td></tr><tr><td> `starting_time` </td> <td> Большое целое число </td>  <td> время начала движения (в секундах) </td></tr><tr><td> `drive_from` </td> <td> Внешний ключ </td> <td> PointOfInterest, из котрого выезжает автомобиль</td></tr><tr><td> `drive_to` </td> <td> Внешний ключ </td> <td> PointOfInterest, в котрый въезжает автомобиль</td></tr></table> |
| RoadLoadEvent | Событие загрузки дороги: на дороге появился автомобиль | <table><tr><td> `road` </td> <td> Внешний ключ </td> <td> Road: дорога, на которой создалась нагрузка </td></tr><tr><td> `load_started` </td> <td> Большое целое число </td> <td> Время, в __секундах__ когда началась нагрузка </td></tr><tr><td> `load_ended` </td> <td> Большое целое число </td> <td> Время, в __секундах__ когда нагрузка завершилась </td></tr></table> |
                    
Схема базы данных представлена на рисунке ниже. К именам полей, которые являлись внешними ключами, добавлен постфикс `_id`, так же, как это делает Django для создания базы в момент миграции: 

![Imgur](http://i.imgur.com/EUxZJGg.png)

Органнизция работы с базой данных: создание, миграции, доступ описаны в разделе разворачивания.

<a name="control"></a>
## Контроллеры

Вся логика приложения размещена в контроллерах, как это и предполагается при использовании MVC. Код контроллеров расположен в файле `views.py`. Имя файла стандартное, имеет такое название потому что принцип работы контроллеров в Django несколько отличается от стандартных MVC-фреймвроков. 

Django использует понятие MVT (Model-View-Template), где под Представлением (View) понимается слой, который работает с данными с уровня Моделей и формирует их особым образом для передачи в Шаблон (Template) для отображения. Таким образом, Представление из классической модели MVC здесь называется Шаблоном.

Схема работы всех контроллеров данного приложения одинакова: на вход принимаются POST-запросы от главной страницы (`index.html`), на которой размещены кнопки для отправки данных (создания дорог, машин, или же получения результатов анализа). Затем, параметры запросов валидируются: некоторые поля не могут быть пустыми, некоторые не могут совпадать (см. подробнее в [Шаблонах](#view)). После производится операция с уровнем Моделей, где происходит работа с базой или с библиотекой построения графики. Данные собираются вместе для формирования ответа и передаются пользователю, пройдя оформление в Шаблон. 

Связь переменных из Контроллеров и Шаблонов происходит посредством двух словарей: `request.POST` и `context`.  Первый содержит параметры, передаваемые пользователем через веб-страницу, второй же содержимое страницы. Связь самих же Контроллеров и Шаблонов реализована следующим образом: каждый Контроллер возвращает объект типа `Response`, содержащий `context` и название Шаблона. 

<a name="addcar"></a>
### Контроллер: `addcar`

Находится в файле `views.py`, имеет вид `addcar(request)`.

Создает запись о загрузке дороги какой-либо машиной. Ожидаемые входные параметры  из словаря `request.POST` и ограничения:

| Ключ входного параметра | Описание | Ограничение |
|:----------:|----------|-------------|
| `name` | название автомобиля | не может быть пустым |
| `speed` | скорость автомобиля | положительное число |
| `car_from` | идентификатор пункта отправления | (список пунктов передается из базы, здесь только валидные данные) |
| `car_to` | идентификатор пункта прибытия | аналогично прошлому ключу |
| `hrstart` | час отправления | лежит в пределах [0;24)  |
| `minstart` | минута отправления | лежит в пределах [0;60) |

Затем, в случае корректности _всех_ парамтеров вызывается функция `addcar` из модуля `funcs`, создающая список смежности для определения нагрузок и добавляющая в базу новую машину (модель `Car`), а также события нагрузки дороги (модель `RoadLoadEvent`).

В итоге, переадресовывает пользователя на `added.html`, выдавая сообщение об успехе или об ошибке посредством значения для ключа `msg` в словаре `context`

<a name="addroad"></a>
### Контроллер: `addroad`

Находится в файле `views.py`, имеет вид `addroad(request)`.

Создает дорогу между двумя пунктами.

Параметры:

| Ключ входного параметра | Описание | Ограничение |
|:----------:|----------|-------------|
| `road_name` | название дороги | не может быть пустым |
| `road_length` | длина дороги | положительное число |
| `rasfrom` | идентификатор исходного пункта дороги | (список пунктов передается из базы, здесь только валидные данные) |
| `rasto` | идентификатор входного пункта дороги | аналогично прошлому ключу |

В случае успеха и отсутствия такой же существующей дороги, добавляется в базу (модель `Road`). 

Дальнейшие действия аналогичны прошлому контроллеру.


<a name="addplace"></a>
### Контроллер: `addplace`

Находится в файле `views.py`, имеет вид `addplace(request)`

Добавляет пункт.

Параметры:

| Ключ входного параметра | Описание | Ограничение |
|:----------:|----------|-------------|
| `place_name` | название пункта | не может быть пустым |

<a name="vs"></a>
### Контроллер: `viewstat`

Находится в файле `views.py`, имеет вид `viewstat(request)`

Выводит диаграмму на веб-страницу по данной дороге и промежутку времени.

Параметры:

| Ключ входного параметра | Описание | Ограничение |
|:----------:|----------|-------------|
| `anroad` | идентификатор дороги | (список пунктов передается из базы, здесь только валидные данные) |
| `from_hr` | час начала анализа |  лежит в пределах [0;24) |
| `from_min` | минута начала анализа |  лежит в пределах [0;60) |
| `to_hr` | час конца анализа |  лежит в пределах [0;24) |
| `to_min` | минута конца анализа | лежит в пределах [0;60) |

После валидации входных данных, идет агрегриющий запрос по модели `RoadLoadEvent`, на основании которого происходит создание файла `fig.png` с столбчатой диаграммой. Файл кладется в локальное хранилище статических файлов и затем подгружается в Шаблоне `chart.html`. 

Пользователь переадресовывается на страницу `chart.html` в случае успеха или же на `added.html` в случае ошибки. 

<a name="index"></a>
### Контроллер: `index`

Занимается созданием стартовой страницы, передавая в нее данные из базы посредством словаря `context`. В основном, это количество находящихся в базе объектов или списки этих объектов. Таким образом, не требуется дополнительная валидация этих данных на момент приема от пользователя, а также позволяет создать списки, содержащие доступные пункты или дороги. 

| Ключ входного параметра | Описание |
| :----: | :---- |
| `count_points` | Количество точек |
| `count_roads` | Количество дорог | 
| `poi` | Список всех точек |
| `roads` | Список всех дорог |

---

<a name="view"></a>
## Представления/Шаблоны

Существует три шаблона, которые отображают данные: 

* `index.html` - стартовая страница
* `added.html` - информация о добавлении объектов или ошибке
* `chart.html` - отображение графика

Все страницы принимают указанные данные из контроллеров через словарь `context`, который был описан выше.

Внешний вид результирующих страниц:

`index.html`

![main](http://i.imgur.com/QQzWejk.png)

`added.html`

![Imgur](http://i.imgur.com/rMqf7vq.png)

`chart.html`

![Imgur](http://i.imgur.com/mxn98g4.png)

<a name="funcs"></a>
## Примеры и функции

<a name="workcar"></a>
### Работа с автомобилем

Функции добавления автомобиля, которые рассчитывают нагрузку по дорогам находятся в файле `funcs.py`. Раразботчику рекомендуется хранить свои дополнительные функции в этом же модуле.

Реализованные функции:

<a name="add_car_fn"></a>
#### add_car(cname, spd, pfrom, pto, hr, mn, sec)
Функция, добавляющая автомобиль. Принимает параметры:

| Параметр | Ожидаемый тип | Описание |
|:----------:|----------|-------------|
| `cname` | строка | Метка автомобиля|
| `spd` | дробное или целое (приводится к `float`) | Скорость автомобиля |
| `pform` | целое | идентификатор пункта отправления |
| `pto` | целое |  идентификатор пункта назначения |
| `hr` | целое, лежит в пределах [0;24)| час выезда |
| `min` | целое,  лежит в пределах [0;60) | минута выезда | 
| `sec` | целое, лежит в пределах [0;60) | секунда выезда | 

При вызове этой функции выбираются объекты `PointOfInterest` из базы и рассчитывается путь при помощи алгоритма Дейкстры, представленном в функции `djikstra` из того же файла.

Для каждой вершины из пути графа, выбирается дорога, соединяющая вершины, и для них добавляется запись в таблицу  `RoadLoadEvent`.

<a name="djikstra"></a>

#### djikstra(all\_conns, from_vertex, dest)

Возвращает список, содержащий путь, состоящий из вершин графа.

| Параметр | Ожидаемый тип | Описание |
|:----------:|----------|-------------|
| `all_cons` | список | Список дорог|
| `from_vertex` | целое | Идентификатор пункта отправления  |
| `dest` | целое | Идентификатор пункта прибытия |

Функция реализует алгоритм Дейкстры и рассчитывает путь до определенной вершины.

Список дорог генерируется при помощи функции `generate_connection_list`


<a name="gcl"></a>
#### generate\_connection_list()

Функция получает список все дорог из базы и создает список кортежей вида  `(исходный пункт, конечный пункт, протяженность)`


<a name="example"></a>
#### Пример использования

Рассмотрим детально `add_car`:

Переведем полученные параметры времени в секунды: 

    
    dt = hr * 3600 + mn * 60 + sec
    
Получим экземпляры объектов локаций:

    location_from = PointOfInterest.objects.get(pk=pfrom)
    location_to = PointOfInterest.objects.get(pk=pto)

Создадим запись об автомобиле: 

    Car(name=cname, speed=spd,
        drive_from=location_from,
        drive_to=location_to,
        starting_time=dt).save()

Получим путь из `location_from` в `location_to`:

    path = djikstra(generate_connection_list(), location_from.name, location_to.name)

Получим экземпляры дорог. Если дороги из `locs[i]` в `locs[i+1]` не существует, но запись в пути есть,  то добавим обратную дорогу:

    locs = []
    for p in path:
        locs.append(PointOfInterest.objects.get(name=p))

    roads = []
    for i in range(0, len(locs) - 1):
        try:
            roads.append(Road.objects.get(point_from=locs[i], point_to=locs[i+1]))
        except Road.DoesNotExist:
            roads.append(Road.objects.get(point_from=locs[i+1], point_to=locs[i]))

Добавим заиси о нагруженности дороги: 

    current_time = dt
    for road in roads:
        prev_time = current_time
        current_time += int((road.length / spd) * 3600)
        RoadLoadEvent(road=road,
                      load_started=prev_time,
                      load_ended=current_time).save()

<a name="example2"></a>
### Пример работы с моделями

Данный пример можно найти в `management/commands/data_preload.py`

Создадим список локаций:

    points = ['Del Apierro',
              'Benjtown',
              'Coherence Village',
              'Demington',
              'Elberdo']

Сохраним их в базу, передав значение поля `name`:

        for point in points:
            PointOfInterest(name=point).save()

Создадим кортежи для дорог вида `(название, протяженность, экземпляр пункта отправления, экземляр пункта прибытия)`

        roads = [('Meadown Interstate',
                  10.0,
                  PointOfInterest.objects.get(name=points[0]),
                  PointOfInterest.objects.get(name=points[1])),
                 ('Hollywag Road',
                  25.0,
                  PointOfInterest.objects.get(name=points[0]),
                  PointOfInterest.objects.get(name=points[3])),
                 ('Bachelor Path',
                  5.0,
                  PointOfInterest.objects.get(name=points[1]),
                  PointOfInterest.objects.get(name=points[2])),
                 ('Some Road',
                  6.0,
                  PointOfInterest.objects.get(name=points[3]),
                  PointOfInterest.objects.get(name=points[2])),
                 ('Escape Route',
                  7.0,
                  PointOfInterest.objects.get(name=points[3]),
                  PointOfInterest.objects.get(name=points[4]))
                 ]

Сохарним их в базу, создав объекты соответствующего типа с соответсвующими названиями полей:


        for road in roads:
            Road(**dict(zip(['name', 'length', 'point_from', 'point_to'], road))).save()

Добавим записи о машинах. Пусть, будет две машины, которые выехали из `Del Apierro` в `Coherence Village` со скоростью 40 км/ч в 10:00 и 10:02 соответственно:
            
        funcs.add_car("RedCar", 40, 1, 3, 10, 0, 0)
        funcs.add_car("BlueCar", 40, 1, 3, 10, 2, 0)

Все эти данные должны быть в таблицах, в чем можно убедиться, подключившись к базе и выполнив команды:


    ra=> select * from ra_pointofinterest;
	 id |       name
	----+-------------------
	  1 | Del Apierro
	  2 | Benjtown
	  3 | Coherence Village
	  4 | Demington
	  5 | Elberdo
	(5 rows)
	
	ra=> select * from ra_road;
	 id |        name        | length | point_from_id | point_to_id
	----+--------------------+--------+---------------+-------------
	  1 | Meadown Interstate |     10 |             1 |           2
	  2 | Hollywag Road      |     25 |             1 |           4
	  3 | Bachelor Path      |      5 |             2 |           3
	  4 | Some Road          |      6 |             4 |           3
	  5 | Escape Route       |      7 |             4 |           5
	(5 rows)
	
	ra=> select * from ra_car;
	 id | drive_from_id | drive_to_id | speed | starting_time |  name
	----+---------------+-------------+-------+---------------+---------
	  1 |             1 |           3 |    40 |         36000 | RedCar
	  2 |             1 |           3 |    40 |         36120 | BlueCar
	(2 rows)
	
	
	ra=> select * from ra_roadloadevent;
	 id | road_id | load_started | load_ended
	----+---------+--------------+------------
	  1 |       1 |        36000 |      36900
	  2 |       3 |        36900 |      37350
	  3 |       1 |        36120 |      37020
	  4 |       3 |        37020 |      37470
	(4 rows)


------
<a name="url"></a>
## Маршрутизаторы

Для связи адресов, по которым переходят пользователи, стандартными средствами Django реализована маршрутизация, связывающая Контроллер и какой-либо адрес, подходящий под регулярное выражение.

Связи хранятся в списке `urlpatterns` в файле `urls.py`. Список состоит из записей вида:

  url(r'^addcar$', views.addcar, name='addcar')
  
Которые создают объект типа `url` с параметрами: регулряное выражения для адреса, назвние метода для представления и 

---

<a name="settings"></a>
## Настройки

В настройках (`settings.py`) задано подключение к базе данных по внутреннему IP Docker-сервиса, порт для запуска приложения и разрешенные адреса для связи процесса с сетевым интерфейсом. 


--- 

<a name="deploy"></a>
## Развертывание проекта

Шаги:

* Обеспечить наличие `docker`, `python>=2.7`, `pip` на сервере.
* Склонировтаь проект из репозитория.
* В директории `db` есть необходимые файлы для создания образа контейнера базы данных. Нужно собрать образ командой `docker build -t radb .`
* Запустить базу: `docker run -p 5432:5432 -d radb`
* Установить зависимости проекта при помощи команды `pip install -r requirements.txt`
* Находясь в корне репозитория, мигрировать таблицы для моделей проекта: `python manage.py migrate`
* (ОПЦИОНАЛЬНО) Загрузить некоторые тестовые данные комадной: `python manage.py data_preload`
* Запустить сервер: `python manage.py runserver`
* Сервер доступен по адресу `localhost:8000` 

---

<a name="repo"></a>
## Репозиторий

[Репозиторий проекта на GitHub](https://github.com/ka2m/study/tree/master/oop/roadanalyze)

---

<a name="dev"></a>
## Разработчик

Влад Слепухин, 251 группа, 2015 год

---

<a name="license"></a>
## Лицензия

BSD
